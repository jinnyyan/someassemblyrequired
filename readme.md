# CyberStakes Some Assembly Required Challenge

Walkthrough for the highest-point flag in CyberStakes 2018. This event was extremely well-run and educational. Thanks a ton to the organizers!

## Overview

This challenge was quite involved and required chaining together a few different steps. These were:

* Reversing the main miner <-> C2 communication encryption
* Discovering a SQL injection vulnerabilty in the C2 server
* Recovering the reward-generating JavaScript payload
* Overcoming JavaScript obfuscation and anti-debugging measures
* Bypassing another layer of encryption

## Getting Acquainted

At first glance, the target website appeared to be a static blog without much going on and no pages aside from the index. However, my computer's fan soon became much louder, prompting me to open Chrome's dev tools and look at what was going on. To my surpise, there was quite a bit of activity going on.

The first thing interesting thing that happened on page load was the spawning of a [Web Worker](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers). For those unfamiliar, a Web Worker is a modern web feature that allows for executing JavaScript in a separate thread from the main one. The [`worker.js`](./worker.js) script being run didn't do much besides set a few configuration variables and kick off execution of the `miner.js` script.

The [`miner.js`](./miner.js) script is a beast, but not too complex once you figure out what's going on. It is mainly boilerplate generated by the [Emscripten](https://developer.mozilla.org/en-US/docs/Mozilla/Projects/Emscripten) compiler, which is a powerful tool commonly used to compile C and C++ code into JavaScript to be run in the browser or other JavaScript runtimes like [Node.js](https://nodejs.org/en). However, in this case, it was paired with the equally powerful [`asm.js`](http://asmjs.org/) project to execute a WebAssembly file.

[WebAssembly](https://webassembly.org/) is another modern web feature that is an attempt to bring a computationally-efficient and portable JavaScript-alternative to browser runtimes. It is a stack-based opcode language that isn't too tough to grok if you read some of the great resources online, like [here](https://github.com/sunfishcode/wasm-reference-manual).

So what was this WebAssembly payload actually doing to my poor laptop fan? For starters, I noticed that two [IndexedDB](https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API) tables were created in my browser's local storage. One was named `blocks` and the other was named `rewards`, as shown below.

![IndexedDB tables](./img/crypt1/indexeddb.png "IndexedDB tables")

As shown in the screenshot, this table was periodically filling up with data. My next step was to perform some static analysis on the WebAssembly binary on the server to get a better understanding of the bulk of the payload.

TODO

## Reversing `crypt1`

Knowing that the mining client was both sending and receiving some type of encrypted / obfuscated payload to and from the C2 server, the first obvious step appeared to be reversing this communication stream. This would allow us to communicate directly with the server to both gather more information as well as poke around for vulnerabilities.

TODO

## Talking with the C2 Server

Great. So now that we can talk freely with the C2 server, the flag should be just around the corner (ha!).

TODO

## JavaScript De-obfuscation

TODO

## Rewards

TODO

This is simply the ASCII flag: `ACI{f15a13ed9d6cae2acc66a217ccc}`. Too easy.